defmodule Legion.AIAgent do
  @moduledoc """
  Behaviour for defining Legion AI agents.

  AI agents are modules that define a task-solving entity powered by an LLM.
  They have access to a set of tools and can execute generated Elixir code
  to accomplish their tasks.

  ## Usage

      defmodule MyApp.DataAgent do
        @moduledoc \"\"\"
        Agent to fetch and process data from given URLs
        \"\"\"
        use Legion.AIAgent, tools: [MyApp.HTTPTool, MyApp.ProcessTool]

        @impl Legion.AIAgent
        def tool_options(MyApp.HTTPTool) do
          %{timeout: 10_000}
        end

        def tool_options(_), do: %{}

        @impl Legion.AIAgent
        def output_schema do
          %{
            type: :object,
            properties: %{
              summary: %{type: :string},
              count: %{type: :integer}
            }
          }
        end

        @impl Legion.AIAgent
        def config do
          %{
            model: "openai:gpt-4o",
            max_iterations: 5
          }
        end

        @impl Legion.AIAgent
        def system_prompt do
          \"\"\"
          Always validate URLs before fetching.
          Prefer JSON responses when available.
          \"\"\"
        end
      end

  ## Callbacks

  All callbacks have default implementations and are optional:

  - `tool_options/1` - Returns options for a specific tool (stored via Vault)
  - `output_schema/0` - Expected result format for the agent
  - `config/0` - Agent-specific configuration overrides
  - `system_prompt/0` - Additional instructions appended to the generated prompt
  """

  @doc """
  Returns options for a specific tool module.

  These options are stored via Vault and accessible within the tool
  using `Vault.get(ToolModule, default)`.
  """
  @callback tool_options(tool_module :: module()) :: map()

  @doc """
  Returns the expected output schema for the agent's result.

  When defined, the LLM is instructed to return results conforming
  to this schema when using `{"action": "return", "result": ...}`.

  Defaults to `[response: [type: :string, required: true]]`.
  """
  @callback output_schema() :: keyword()

  @doc """
  Returns agent-specific configuration overrides.

  These are merged with global config and call options.
  Priority: call opts > agent config > app env > defaults
  """
  @callback config() :: map()

  @doc """
  Returns additional system prompt instructions.

  These are appended to the generated system prompt (after tool docs
  and response format instructions).
  """
  @callback system_prompt() :: String.t() | nil

  @doc """
  Returns sandbox options for code execution.

  These options control resource limits for sandboxed code evaluation.
  Common options include:
  - `:timeout` - Max execution time in ms (default: 50)
  - `:max_heap_size` - Memory limit (default: 50_000)
  - `:max_reductions` - CPU cycles limit (default: 30_000)

  ## Example

      @impl Legion.AIAgent
      def sandbox_options do
        [
          timeout: 5000,
          max_heap_size: 100_000
        ]
      end
  """
  @callback sandbox_options() :: keyword()

  @doc """
  Returns agent metadata for Legion.

  This is automatically generated by the `use Legion.AIAgent` macro.
  """
  @callback __legion_agent_info__() :: %{
              module: module(),
              moduledoc: String.t() | nil,
              tools: [module()]
            }

  defmacro __using__(opts) do
    tools = Keyword.get(opts, :tools, [])

    # Generate `allow ToolModule, :all` for each tool
    allow_statements =
      Enum.map(tools, fn tool ->
        quote do
          allow(unquote(tool), :all)
        end
      end)

    quote do
      # Make this agent module itself a Dune allowlist (must come first
      # due to Dune's behaviour check using Keyword.get instead of get_values)
      use Dune.Allowlist, extend: Dune.Allowlist.Default

      unquote_splicing(allow_statements)

      @behaviour Legion.AIAgent
      @legion_tools unquote(tools)
      @before_compile Legion.AIAgent

      @impl Legion.AIAgent
      def tool_options(_tool_module), do: %{}

      @impl Legion.AIAgent
      def output_schema, do: [response: [type: :string, required: true]]

      @impl Legion.AIAgent
      def config, do: %{}

      @impl Legion.AIAgent
      def system_prompt, do: nil

      @impl Legion.AIAgent
      def sandbox_options, do: []

      defoverridable tool_options: 1,
                     output_schema: 0,
                     config: 0,
                     system_prompt: 0,
                     sandbox_options: 0
    end
  end

  defmacro __before_compile__(env) do
    module = env.module
    tools = Module.get_attribute(module, :legion_tools) || []
    moduledoc = Module.get_attribute(module, :moduledoc)

    moduledoc_text =
      case moduledoc do
        {_line, doc} when is_binary(doc) -> doc
        _ -> nil
      end

    quote do
      @impl Legion.AIAgent
      def __legion_agent_info__ do
        %{
          module: unquote(module),
          moduledoc: unquote(moduledoc_text),
          tools: unquote(tools)
        }
      end
    end
  end
end
